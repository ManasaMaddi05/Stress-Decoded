<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Exam Stress Visualization</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;700&display=swap" rel="stylesheet">
  <script>
    tailwind.config = {
      theme: {
        extend: {
          fontFamily: {
            'sans': ['Inter', 'sans-serif'],
            'mono': ['"JetBrains Mono"', 'monospace'],
          },
          colors: {
            'stress': {
              100: '#f3e8ff',
              200: '#e9d5ff',
              300: '#d8b4fe',
              400: '#c084fc',
              500: '#a855f7',
              600: '#9333ea',
              700: '#7e22ce',
              800: '#6b21a8',
              900: '#581c87',
            },
            'calm': {
              100: '#e0f2fe',
              200: '#bae6fd',
              300: '#7dd3fc',
              400: '#38bdf8',
              500: '#0ea5e9',
              600: '#0284c7',
              700: '#0369a1',
              800: '#075985',
              900: '#0c4a6e',
            }
          },
          backgroundImage: {
            'stress-gradient': 'linear-gradient(to bottom right, #581c87, #7f1d1d)',
          },
          boxShadow: {
            'glow': '0 0 15px rgba(168, 85, 247, 0.5)',
            'calm-glow': '0 0 15px rgba(14, 165, 233, 0.5)',
          },
          animation: {
            'pulse-slow': 'pulse 4s cubic-bezier(0.4, 0, 0.6, 1) infinite',
          },
        }
      }
    }
  </script>
  <style>
    /* Add these styles for the landing page elements */
    @import url('css/landing-page.css');
    
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      font-family: 'Inter', sans-serif;
      background-color: #0d1b3d;
    }
    
    .fullpage-container {
      height: 100vh;
      overflow-y: auto;
      scroll-snap-type: y mandatory; /* Change from proximity to mandatory for true snap */
      scroll-behavior: smooth;
      position: relative;
      background-color: #0d1b3d;
      overscroll-behavior-y: contain; /* Prevent browser overscroll */
    }
    
    .section {
      height: 100vh;
      width: 100%;
      position: relative;
      scroll-snap-align: start;
      scroll-snap-stop: normal; /* Change from always to normal for smoother scrolling */
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 1 !important;
      pointer-events: auto !important;
      transform: none !important;
    }
    
    .section.active {
      opacity: 1;
      pointer-events: all;
    }
    
    /* Add previous and next section states for smoother transitions */
    .section.prev, .section.next {
      opacity: 1 !important;
      transform: none !important;
    }
    
    .section-frame {
      width: 100%;
      height: 100%;
      border: none;
      display: block !important;
    }
    
    .scroll-indicator {
      position: fixed;
      top: 50%;
      right: 4rem;
      transform: translateY(-50%);
      z-index: 50;
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
    
    .scroll-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      border: 2px solid rgba(255, 255, 255, 0.7);
      background-color: transparent;
      transition: all 0.3s ease;
      cursor: pointer;
    }
    
    .scroll-dot:hover {
      transform: scale(1.2);
    }
    
    .scroll-dot.active {
      background-color: white;
      box-shadow: 0 0 8px rgba(255, 255, 255, 0.8);
    }
    
    .heart-bg {
      position: absolute;
      inset: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      pointer-events: none;
      z-index: 1;
      overflow: hidden;
      background: linear-gradient(to bottom, #0d1b3d 0%, #162b60 100%);
    }
    
    .heart-svg {
      width: min(50vw, 600px);
      height: auto;
      opacity: 0.25;
      animation: heartbeat 1.5s ease-in-out infinite;
      transition: opacity 0.8s ease-in-out;
      filter: drop-shadow(0 4px 10px rgba(255, 255, 255, 0.1));
      transform-origin: center;
    }
    
    @keyframes heartbeat {
      0%, 100% {
        transform: scale(1);
      }
      50% {
        transform: scale(1.12);
      }
    }
    
    .fade-in {
      opacity: 0;
      transform: translateY(16px);
      transition: opacity 1s ease-out, transform 1s ease-out;
    }
    
    .fade-in.visible {
      opacity: 1;
      transform: translateY(0);
    }
    
    .delay-300 {
      transition-delay: 300ms;
    }
    
    .delay-600 {
      transition-delay: 600ms;
    }
    
    .metric {
      font-family: 'JetBrains Mono', monospace;
      text-shadow: 0 0 10px rgba(168, 85, 247, 0.7);
    }
    
    .metric-calm {
      font-family: 'JetBrains Mono', monospace;
      text-shadow: 0 0 10px rgba(14, 165, 233, 0.7);
    }
    
    /* Progress indicator */
    .progress-bar {
      position: fixed;
      top: 0;
      left: 0;
      height: 3px;
      background: linear-gradient(to right, #a855f7, #0ea5e9);
      z-index: 100;
      transition: width 0.3s ease;
    }

    /* Add tooltip styles */
    .tooltip {
      position: fixed;
      top: 20px;
      left: 20px;
      background: rgba(15, 23, 42, 0.9);
      color: white;
      padding: 12px 16px;
      border-radius: 8px;
      font-family: 'Inter', sans-serif;
      font-size: 14px;
      z-index: 1000;
      backdrop-filter: blur(8px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      transition: all 0.3s ease;
      cursor: pointer;
    }

    .tooltip:hover {
      background: rgba(30, 41, 59, 0.9);
      transform: translateY(-2px);
    }

    .tooltip-popup {
      position: fixed;
      top: 70px;
      left: 20px;
      background: rgba(15, 23, 42, 0.95);
      color: white;
      padding: 20px;
      border-radius: 12px;
      font-family: 'Inter', sans-serif;
      font-size: 14px;
      z-index: 1000;
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
      display: none;
      min-width: 400px;
      max-width: 500px;
      line-height: 1.5;
    }

    .tooltip-popup ul {
      list-style-type: disc;
      padding-left: 20px;
      margin: 0;
    }

    .tooltip-popup li {
      margin-bottom: 8px;
    }
  </style>
</head>
<body class="font-sans">
  <!-- Add tooltip button -->
  <div class="tooltip" id="info-tooltip">Info</div>
  <div class="tooltip-popup" id="tooltip-popup">
    <ul>
      <li><strong>BVP (Blood Volume Pulse):</strong> Measures changes in blood flow with each heartbeat. Higher BVP may reflect increased arousal or stress.</li>
  <li><strong>HR (Heart Rate):</strong> The number of heartbeats per minute. A higher HR can indicate excitement, stress, or physical exertion.</li>
  <li><strong>Temp (Skin Temperature):</strong> Measures peripheral skin temperature. Drops can signal stress or anxiety as blood flow shifts inward.</li>
  <li><strong>EDA (Electrodermal Activity):</strong> Tracks sweat gland activity, a direct indicator of emotional arousal and stress response.</li>
    </ul>
  </div>

  <!-- Countdown Timer Overlay (from landing1.html) -->
  <div id="countdown-overlay" class="fixed inset-0 bg-black z-50 flex items-center justify-center">
    <div class="wall-clock">
      <div class="clock-frame">
        <div class="clock-face">
          <div class="clock-markings">
            <div class="hour-mark mark-12">12</div>
            <div class="hour-mark mark-1">1</div>
            <div class="hour-mark mark-2">2</div>
            <div class="hour-mark mark-3">3</div>
            <div class="hour-mark mark-4">4</div>
            <div class="hour-mark mark-5">5</div>
            <div class="hour-mark mark-6">6</div>
            <div class="hour-mark mark-7">7</div>
            <div class="hour-mark mark-8">8</div>
            <div class="hour-mark mark-9">9</div>
            <div class="hour-mark mark-10">10</div>
            <div class="hour-mark mark-11">11</div>
          </div>
          <div class="clock-hands">
            <div class="hour-hand"></div>
            <div class="minute-hand"></div>
            <div class="second-hand"></div>
            <div class="clock-center"></div>
          </div>
          <div id="countdown-timer" class="exam-timer font-mono text-red-500 countdown-glow">00:03</div>
        </div>
      </div>
      <div class="clock-pendulum">
        <div class="pendulum-rod"></div>
        <div class="pendulum-bob"></div>
      </div>
    </div>
    <div id="countdown-pulse" class="absolute w-full h-full pointer-events-none"></div>
    <div id="exam-elements" class="absolute inset-0 pointer-events-none">
      <div class="pencil"></div>
      <div class="paper"></div>
      <div class="calculator"></div>
      <div class="coffee-cup"></div>
    </div>
    <div id="pun-message" class="text-center text-white font-bold opacity-0 transition-opacity duration-500">
      Exam's Over!
    </div>
  </div>

  <!-- Progress bar -->
  <div class="progress-bar" id="progress-bar"></div>
  
  <div class="scroll-indicator hidden md:flex">
    <div class="scroll-dot active" data-section="intro"></div>
    <div class="scroll-dot" data-section="section-1"></div>
    <div class="scroll-dot" data-section="section-2"></div>
    <div class="scroll-dot" data-section="section-3"></div>
    <div class="scroll-dot" data-section="section-4"></div>
    <div class="scroll-dot" data-section="section-5"></div>
    <div class="scroll-dot" data-section="conclusion"></div>
  </div>

  <!-- Main Content (initially hidden) -->
  <main class="fullpage-container opacity-0 transition-opacity duration-1000" id="fullpage-container">
    <section id="intro" class="section active">
      <div class="heart-bg">
        <svg class="heart-svg" viewBox="0 0 32 32" fill="white" xmlns="http://www.w3.org/2000/svg">
          <path d="M16 28.7c-.7 0-1.4-.3-1.9-.8L4.8 18.6C1.7 15.5 1.7 10.4 4.8 7.3c1.5-1.5 3.5-2.3 5.6-2.3s4.1.8 5.6 2.3L16 7.3l.1-.1c1.5-1.5 3.5-2.3 5.6-2.3s4.1.8 5.6 2.3c3.1 3.1 3.1 8.2 0 11.3L17.9 27.9c-.5.5-1.2.8-1.9.8z"/>
        </svg>
      </div>
      
      <!-- Overlaid Content Block -->
      <div class="absolute inset-0 flex items-center justify-center z-10">
        <div class="text-center px-4">
          <h1 class="text-4xl md:text-6xl font-bold text-white tracking-wide leading-tight fade-in shadow-glow">
            What Does <span class="metric text-stress-400">Stress</span> Look Like in Exams?
          </h1>
          <p class="text-lg md:text-2xl font-medium text-white/90 italic text-center max-w-xl mx-auto mt-4 fade-in delay-300">
            Ten students. Three exams. One question: does stress help or hurt?
          </p>
          <div class="mt-8 fade-in delay-600">
            <a href="#section-1" class="cursor-pointer scroll-arrow">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-10 w-10 mx-auto text-white animate-bounce" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 14l-7 7m0 0l-7-7m7 7V3" />
              </svg>
            </a>
          </div>
        </div>
      </div>
    </section>
    
    <section id="section-1" class="section">
      <iframe src="desks.html" class="section-frame" title="Heart Rate Patterns"></iframe>
    </section>
    
    <section id="section-2" class="section">
      <iframe src="student-heart-monitor.html" class="section-frame" title="Electrodermal Activity"></iframe>
    </section>
    
    <section id="section-3" class="section">
      <iframe src="student-timeline.html" class="section-frame" title="Student Timeline"></iframe>
    </section>
    
    <section id="section-4" class="section">
      <iframe src="run-bar.html" class="section-frame" title="Physiological Metrics Analysis"></iframe>
    </section>
    
    <section id="section-5" class="section">
      <iframe src="student-scatter-plot.html" class="section-frame" title="Performance Correlation"></iframe>
    </section>
    
    <section id="conclusion" class="section">
      <iframe src="reflection-wall.html" class="section-frame" title="Key Findings"></iframe>
    </section>
  </main>

  <script>
    document.addEventListener('DOMContentLoaded', function() {
      // Add tooltip click functionality
      const tooltip = document.getElementById('info-tooltip');
      const tooltipPopup = document.getElementById('tooltip-popup');
      
      tooltip.addEventListener('click', function() {
        if (tooltipPopup.style.display === 'none' || !tooltipPopup.style.display) {
          tooltipPopup.style.display = 'block';
        } else {
          tooltipPopup.style.display = 'none';
        }
      });

      // Close tooltip when clicking outside
      document.addEventListener('click', function(event) {
        if (!tooltip.contains(event.target) && !tooltipPopup.contains(event.target)) {
          tooltipPopup.style.display = 'none';
        }
      });

      // Preload audio files (from landing1.html)
      const tickSound = new Audio('sounds/clock-tick.mp3');
      tickSound.volume = 0.9;
      tickSound.preload = 'auto';
      
      const finalSound = new Audio('sounds/school-bell.mp3');
      finalSound.volume = 0.9;
      finalSound.preload = 'auto';
      
      // Force audio to load
      tickSound.load();
      finalSound.load();
      
      // Countdown timer functionality
      const countdownOverlay = document.getElementById('countdown-overlay');
      const countdownTimer = document.getElementById('countdown-timer');
      const countdownPulse = document.getElementById('countdown-pulse');
      const mainContent = document.getElementById('fullpage-container');
      const punMessage = document.getElementById('pun-message');
      
      // Animate clock hands
      const hourHand = document.querySelector('.hour-hand');
      const minuteHand = document.querySelector('.minute-hand');
      const secondHand = document.querySelector('.second-hand');
      
      // Set initial random positions for hands
      hourHand.style.transform = `rotate(${Math.random() * 360}deg)`;
      minuteHand.style.transform = `rotate(${Math.random() * 360}deg)`;
      
      // Initialize audio context on user interaction
      let audioContext;
      
      // Function to initialize audio context
      function initAudio() {
        if (!audioContext) {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
          document.removeEventListener('click', initAudio);
          document.removeEventListener('keydown', initAudio);
        }
      }
      
      // Add event listeners to initialize audio context on user interaction
      document.addEventListener('click', initAudio);
      document.addEventListener('keydown', initAudio);
      
      // Alternative audio playback function using multiple approaches
      function playSound(sound) {
        // Try the standard way first
        const playPromise = sound.play();
        
        if (playPromise !== undefined) {
          playPromise.catch(error => {
            console.log('Audio play prevented, trying alternative method:', error);
            
            // If standard play fails, try creating a new Audio instance
            const newSound = new Audio(sound.src);
            newSound.volume = sound.volume;
            newSound.play().catch(e => console.log('Alternative method also failed:', e));
            
            // Also try with audio context as a last resort
            if (audioContext) {
              try {
                const source = audioContext.createBufferSource();
                fetch(sound.src)
                  .then(response => response.arrayBuffer())
                  .then(arrayBuffer => audioContext.decodeAudioData(arrayBuffer))
                  .then(audioBuffer => {
                    source.buffer = audioBuffer;
                    source.connect(audioContext.destination);
                    source.start(0);
                  });
              } catch (e) {
                console.log('Audio context method failed:', e);
              }
            }
          });
        }
      }
      
      // Animate second hand
      let secondRotation = 0;
      const secondHandTick = setInterval(() => {
        secondRotation += 6;
        secondHand.style.transform = `rotate(${secondRotation}deg)`;
        
        // Play tick sound every 5 seconds
        if (secondRotation % 30 === 0) {
          tickSound.currentTime = 0;
          playSound(tickSound);
        }
      }, 1000);
      
      // Start countdown
      let timeLeft = 3;
      
      const countdown = setInterval(() => {
        // Play tick sound for each second
        tickSound.currentTime = 0;
        playSound(tickSound);
        
        timeLeft--;
        
        // Format time as 00:XX
        const formattedTime = `00:0${timeLeft}`;
        countdownTimer.textContent = formattedTime;
        
        // Create pulse effect
        const pulse = document.createElement('div');
        pulse.classList.add('timer-pulse');
        countdownPulse.appendChild(pulse);
        
        // Make timer red and more urgent as we get closer to zero
        countdownTimer.style.color = timeLeft === 1 ? '#ff0000' : '#ff5555';
        countdownTimer.style.textShadow = `0 0 10px rgba(255, ${timeLeft * 85}, ${timeLeft * 85}, 0.7), 0 0 20px rgba(255, ${timeLeft * 85}, ${timeLeft * 85}, 0.7)`;
        
        // Remove pulse after animation
        setTimeout(() => {
          pulse.remove();
        }, 2000);
        
        if (timeLeft <= 0) {
          clearInterval(countdown);
          clearInterval(secondHandTick);
          
          // Play school bell sound
          playSound(finalSound);
          
          // Explosion effect
          countdownTimer.classList.add('explosion-effect');
          countdownOverlay.classList.add('shake-effect');
          
          // Create explosion particles
          for (let i = 0; i < 20; i++) {
            createExplosionParticle();
          }
          
          // Show message with enhanced animation and ensure it's light purple
          setTimeout(() => {
            punMessage.style.opacity = '1';
            punMessage.classList.add('pun-animate');
            punMessage.style.color = '#a5b4fc'; // Force light purple color
            punMessage.style.background = 'rgba(15, 23, 42, 0.7)';
            punMessage.style.textShadow = '0 0 10px rgba(165, 180, 252, 0.8), 0 0 20px rgba(99, 102, 241, 0.7)';
            punMessage.style.border = '1px solid rgba(165, 180, 252, 0.3)';
            punMessage.style.backdropFilter = 'blur(5px)';
            
            // Remove any gradient background that might be overriding
            punMessage.style.backgroundImage = 'none';
            punMessage.style.webkitBackgroundClip = 'initial';
            punMessage.style.webkitTextFillColor = 'initial';
          }, 800);
          
          // Fade out overlay and show main content
          setTimeout(() => {
            countdownOverlay.classList.add('fade-out');
            mainContent.classList.remove('opacity-0');
            
            setTimeout(() => {
              countdownOverlay.style.display = 'none';
              
              // Initialize the main content scrolling functionality
              initMainContent();
              
              // Setup arrow navigation after main content is initialized
              document.querySelectorAll('.scroll-arrow').forEach(arrow => {
                arrow.addEventListener('click', function(e) {
                  e.preventDefault();
                  const targetId = this.getAttribute('href').substring(1);
                  if (window.scrollToSection) {
                    window.scrollToSection(targetId);
                  }
                });
              });
            }, 1000);
          }, 2500);
        }
      }, 1000);
      
      // Function to create explosion particles
      function createExplosionParticle() {
        const particle = document.createElement('div');
        particle.classList.add('explosion-particle');
        
        // Random position, size and color
        const size = Math.random() * 10 + 5;
        const xPos = (Math.random() - 0.5) * 100;
        const yPos = (Math.random() - 0.5) * 100;
        const rotation = Math.random() * 360;
        const duration = Math.random() * 1 + 1;
        
        particle.style.width = `${size}px`;
        particle.style.height = `${size}px`;
        particle.style.background = `hsl(${Math.random() * 30 + 10}, 100%, 50%)`;
        particle.style.setProperty('--x-pos', `${xPos}vw`);
        particle.style.setProperty('--y-pos', `${yPos}vh`);
        particle.style.setProperty('--rotation', `${rotation}deg`);
        particle.style.setProperty('--duration', `${duration}s`);
        
        countdownPulse.appendChild(particle);
        
        // Remove particle after animation
        setTimeout(() => {
          particle.remove();
        }, duration * 1000);
      }
      
      // Initialize main content scrolling functionality
      function initMainContent() {
        const container = document.getElementById('fullpage-container');
        const sections = document.querySelectorAll('.section');
        const scrollDots = document.querySelectorAll('.scroll-dot');
        const fadeElements = document.querySelectorAll('.fade-in');
        const progressBar = document.getElementById('progress-bar');
        
        // Force all sections to be visible
        sections.forEach(section => {
          section.style.opacity = '1';
          section.style.pointerEvents = 'auto';
          section.style.transform = 'none';
          section.style.position = 'relative'; // Change from absolute to relative
        });
        
        // Initialize
        let currentSectionIndex = 0;
        let isScrolling = false;
        let scrollTimeout;
        let lastScrollTop = 0;
        let scrollDirection = 0;
        
        // Make intro fade elements visible
        fadeElements.forEach(el => {
          el.classList.add('visible');
        });
        
        // Update progress bar based on scroll position
        function updateProgressBar() {
          const scrollPosition = container.scrollTop;
          const totalHeight = container.scrollHeight - container.clientHeight;
          const progress = (scrollPosition / totalHeight) * 100;
          progressBar.style.width = `${progress}%`;
        }
        
        // Improved highlight active section function
        function highlightActiveSection() {
          const scrollPosition = container.scrollTop;
          const windowHeight = window.innerHeight;
          
          sections.forEach((section, index) => {
            const sectionTop = section.offsetTop;
            const sectionHeight = section.offsetHeight;
            
            // More lenient check for section visibility
            if (scrollPosition >= sectionTop - windowHeight * 0.6 && 
                scrollPosition < sectionTop + sectionHeight - windowHeight * 0.4) {
              
              // Only update if the section changed
              if (currentSectionIndex !== index) {
                currentSectionIndex = index;
                
                // Update active dot
                scrollDots.forEach((dot, i) => {
                  if (i === index) {
                    dot.classList.add('active');
                  } else {
                    dot.classList.remove('active');
                  }
                });
                
                // Update URL hash without scrolling
                const sectionId = section.id;
                history.replaceState(null, null, `#${sectionId}`);
              }
            }
          });
        }
        
        // Improved smooth scroll to section
        function scrollToSection(index) {
          if (isScrolling) return;
          isScrolling = true;
          
          const targetSection = sections[index];
          
          // Smooth scroll to the target section
          container.scrollTo({
            top: targetSection.offsetTop,
            behavior: 'smooth'
          });
          
          // Update active dot
          scrollDots.forEach((dot, i) => {
            if (i === index) {
              dot.classList.add('active');
            } else {
              dot.classList.remove('active');
            }
          });
          
          // Update current section index
          currentSectionIndex = index;
          
          // Update URL hash
          const sectionId = targetSection.id;
          history.replaceState(null, null, `#${sectionId}`);
          
          // Reset scrolling flag after animation completes
          clearTimeout(scrollTimeout);
          scrollTimeout = setTimeout(() => {
            isScrolling = false;
          }, 800);
        }
        
        // Improved scroll event listener
        container.addEventListener('scroll', () => {
          // Update progress bar
          updateProgressBar();
          
          // Determine scroll direction
          const st = container.scrollTop;
          scrollDirection = st > lastScrollTop ? 1 : -1;
          lastScrollTop = st;
          
          // Debounce the section highlighting
          clearTimeout(scrollTimeout);
          scrollTimeout = setTimeout(() => {
            highlightActiveSection();
            
            // Check if we need to snap to a section after manual scrolling stops
            if (!isScrolling) {
              const currentScrollPos = container.scrollTop;
              
              // Find the closest section
              let closestSectionIndex = 0;
              let closestDistance = Infinity;
              
              sections.forEach((section, index) => {
                const distance = Math.abs(section.offsetTop - currentScrollPos);
                if (distance < closestDistance) {
                  closestDistance = distance;
                  closestSectionIndex = index;
                }
              });
              
              // Only snap if we're not already very close to a section boundary
              if (closestDistance > 20 && closestDistance < window.innerHeight * 0.3) {
                scrollToSection(closestSectionIndex);
              }
            }
          }, 100);
        });
        
        // Handle dot navigation
        scrollDots.forEach((dot, index) => {
          dot.addEventListener('click', () => {
            scrollToSection(index);
          });
        });
        
        // Improved wheel event handler with less aggressive prevention
        let wheelTimeout;
        container.addEventListener('wheel', function(e) {
          clearTimeout(wheelTimeout);
          
          wheelTimeout = setTimeout(() => {
            if (isScrolling) return;
            
            // Determine scroll direction
            const direction = e.deltaY > 0 ? 1 : -1;
            
            // Calculate target section
            let targetIndex = currentSectionIndex + direction;
            
            // Ensure target index is within bounds
            if (targetIndex >= 0 && targetIndex < sections.length) {
              // Allow some natural scrolling before taking over
              const currentScrollPos = container.scrollTop;
              const currentSection = sections[currentSectionIndex];
              const sectionTop = currentSection.offsetTop;
              
              // Only take over scrolling if we're near a section boundary
              const distanceFromTop = Math.abs(currentScrollPos - sectionTop);
              
              if ((direction > 0 && distanceFromTop > window.innerHeight * 0.7) || 
                  (direction < 0 && distanceFromTop < window.innerHeight * 0.3)) {
                scrollToSection(targetIndex);
              }
            }
          }, 50);
        }, { passive: true }); // Change to passive for better performance
        
        // Add keyboard navigation
        document.addEventListener('keydown', function(e) {
          if (isScrolling) return;
          
          if (e.key === 'ArrowDown' && currentSectionIndex < sections.length - 1) {
            e.preventDefault();
            scrollToSection(currentSectionIndex + 1);
          } else if (e.key === 'ArrowUp' && currentSectionIndex > 0) {
            e.preventDefault();
            scrollToSection(currentSectionIndex - 1);
          }
        });
        
        // Improved touch swipe support
        let touchStartY = 0;
        let touchEndY = 0;
        let touchStartTime = 0;
        
        container.addEventListener('touchstart', function(e) {
          touchStartY = e.changedTouches[0].screenY;
          touchStartTime = Date.now();
        }, { passive: true });
        
        container.addEventListener('touchend', function(e) {
          if (isScrolling) return;
          
          touchEndY = e.changedTouches[0].screenY;
          const touchEndTime = Date.now();
          const diffY = touchStartY - touchEndY;
          const timeDiff = touchEndTime - touchStartTime;
          
          // Only trigger for quick swipes (faster than 300ms)
          if (Math.abs(diffY) > 50 && timeDiff < 300) {
            if (diffY > 0 && currentSectionIndex < sections.length - 1) {
              // Swipe up - go to next section
              scrollToSection(currentSectionIndex + 1);
            } else if (diffY < 0 && currentSectionIndex > 0) {
              // Swipe down - go to previous section
              scrollToSection(currentSectionIndex - 1);
            }
          }
        }, { passive: true });
        
        // Initialize with first section
        updateProgressBar();
        highlightActiveSection();
        
        // Handle initial hash in URL
        if (window.location.hash) {
          const targetId = window.location.hash.substring(1);
          const targetSection = document.getElementById(targetId);
          if (targetSection) {
            const index = Array.from(sections).indexOf(targetSection);
            if (index !== -1) {
              // Use setTimeout to ensure the page is fully loaded
              setTimeout(() => {
                scrollToSection(index);
              }, 500);
            }
          }
        }
        
        // Make scrollToSection available globally
        window.scrollToSection = function(sectionId) {
          const targetSection = document.getElementById(sectionId);
          if (targetSection) {
            const index = Array.from(sections).indexOf(targetSection);
            if (index !== -1) {
              scrollToSection(index);
            }
          }
        };
      }
      
      // Call setupArrowNavigation after the countdown completes
      const originalInitMainContent = initMainContent;
      initMainContent = function() {
        originalInitMainContent();
        setupArrowNavigation();
      };
      
      // If you're not using the countdown, or want arrows to work immediately:
      document.querySelectorAll('a[href^="#"]').forEach(link => {
        link.addEventListener('click', function(e) {
          e.preventDefault();
          const targetId = this.getAttribute('href').substring(1);
          
          // If the main content is already visible, use the scrollToSection function
          if (!document.getElementById('countdown-overlay') || 
              document.getElementById('countdown-overlay').style.display === 'none') {
            if (window.scrollToSection) {
              window.scrollToSection(targetId);
            } else {
              // Fallback if scrollToSection isn't available yet
              const targetElement = document.getElementById(targetId);
              if (targetElement) {
                targetElement.scrollIntoView({ behavior: 'smooth' });
              }
            }
          }
        });
      });
    });
  </script>
</body>
</html>
